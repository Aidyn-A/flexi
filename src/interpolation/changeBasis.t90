!=================================================================================================================================
! Copyright (c) 2010-2016  Prof. Claus-Dieter Munz 
! This file is part of FLEXI, a high-order accurate framework for numerically solving PDEs with discontinuous Galerkin methods.
! For more information see https://www.flexi-project.org and https://nrg.iag.uni-stuttgart.de/
!
! FLEXI is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License 
! as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!
! FLEXI is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
! of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License v3.0 for more details.
!
! You should have received a copy of the GNU General Public License along with FLEXI. If not, see <http://www.gnu.org/licenses/>.
!=================================================================================================================================


!==================================================================================================================================
!> Changes a 2D or 3D tensor product polynomial with Lagrange Basis of degree NIn to
!> 2D or 3D tensor product polynomial of a Lagrange Basis NOut, using two
!> arbitrary point distributions xi_In(0:NIn) and xi_Out(0:NOut) and a series of 1D operations 
!> \f[ \tilde{u}_{:,j} = \mathcal{V}_{1D,(Nout+1)x(Nin+1)}^{-1} \hat{u}_{:,j} \f]
!> \f[ \hat{p}_{i,:} = \mathcal{V}_{1D,(Nout+1)x(Nin+1)}^{-1} \tilde{u}_{i,:} \f]
!==================================================================================================================================


!==================================================================================================================================
!> Interpolate a 3D tensor product Lagrange polynomial defined by (NIn+1) 1D Lagrange basis functions of order (Nin) and node 
!> positions xi_In(0:Nin) to another 3D tensor product Lagrange basis defined by (NOut+1) 1D interpolation points on the node
!> positions xi_out(0:NOut).
!> xi is defined in the 1D referent element \f$ \xi \in [-1,1] \f$.
!> _Mult means that the routine is not restricted to one element, but the data fields of several elements (nElems) is
!> processed.
!==================================================================================================================================
PURE SUBROUTINE ChangeBasis3D_selective(Dim1,NIn,NOut,range_1,range_N,firstind,lastind,Vdm,X_In,X_Out,mask,mask_ref,&
        addToOutput)
!==================================================================================================================================
!==================================================================================================================================
! MODULES
USE MOD_PreProc
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------------------
! INPUT/OUTPUT VARIABLES
INTEGER,INTENT(IN)           :: Dim1,NIn,NOut,firstind,lastind,range_1,range_N
REAL,INTENT(IN)              :: X_In(1:Dim1,0:NIn,0:NIn,0:NIn,range_1:range_N)
REAL,INTENT(IN)              :: Vdm(0:NOut,0:NIn)
REAL,INTENT(INOUT)           :: X_Out(1:Dim1,0:NOut,0:NOut,0:NOut,range_1:range_N)
INTEGER,INTENT(IN),OPTIONAL  :: mask(range_1:range_N)
INTEGER,INTENT(IN),OPTIONAL  :: mask_ref
LOGICAL,INTENT(IN),OPTIONAL  :: addToOutput
!----------------------------------------------------------------------------------------------------------------------------------
! LOCAL VARIABLES
INTEGER             :: iI,jI,kI,iO,jO,kO,Ind,Ind2,iVec
REAL                :: X_Buf1(Dim1*PP_VEC,0:NOut,0:NIn,0:NIn)  ! first intermediate results from 1D interpolations
REAL                :: X_Buf2(Dim1*PP_VEC,0:NOut,0:NOut,0:NIn) ! first intermediate results from 1D interpolations
REAL                :: VECIN (Dim1*PP_VEC,0:NIn,0:NIn,0:NIn)
REAL                :: VECOUT(Dim1*PP_VEC,0:NOut,0:NOut,0:NOut)
INTEGER             :: mask_loc(firstind:lastind), mask_ref_loc
LOGICAL             :: addToOutput_loc
!==================================================================================================================================
IF (PRESENT(mask)) THEN
  mask_loc = mask(firstind:lastind)
  mask_ref_loc = mask_ref
ELSE
  mask_loc = 0
  mask_ref_loc = 0
END IF
addToOutput_loc=.FALSE.
IF (PRESENT(addToOutput)) THEN
  addToOutput_loc = addToOutput
END IF
Ind = firstind
Ind2 = firstind

DO WHILE (Ind.LE.lastind)
  ! pack solution into vector VECIN
  iVec = 1
  DO WHILE (iVec < Dim1*PP_VEC)
    IF (mask_loc(Ind).EQ.mask_ref_loc) THEN
      VECIN(iVec:iVec+Dim1-1,:,:,:) = X_In(:,:,:,:,Ind)
      IF (addToOutput_loc) THEN
        ! initialize VECOUT with X_Out
        VECOUT(iVec:iVec+Dim1-1,:,:,:) = X_Out(:,:,:,:,Ind)
      END IF
      iVec = iVec + Dim1
    END IF
    Ind = Ind + 1
    IF (Ind.GT.lastind) EXIT
  END DO
  ! nullify VECOUT if not initialized with data from X_Out
  IF (.NOT.addToOutput_loc) THEN
    VECOUT=0.
  END IF


  ! first direction iI
  DO kI=0,NIn; DO jI=0,NIn
    DO iO=0,NOut
      X_Buf1(1:iVec-1,iO,jI,kI)=Vdm(iO,0)*VECIN(1:iVec-1,0,jI,kI)
    END DO
    DO iI=1,NIn
      DO iO=0,NOut
        X_Buf1(1:iVec-1,iO,jI,kI)=X_Buf1(1:iVec-1,iO,jI,kI)+Vdm(iO,iI)*VECIN(1:iVec-1,iI,jI,kI)
      END DO
    END DO
  END DO; END DO

  ! second direction jI
  DO kI=0,NIn
    DO jO=0,NOut; DO iO=0,NOut
      X_Buf2(1:iVec-1,iO,jO,kI)=Vdm(jO,0)*X_Buf1(1:iVec-1,iO,0,kI)
    END DO; END DO
    DO jI=1,NIn
      DO jO=0,NOut; DO iO=0,NOut
        X_Buf2(1:iVec-1,iO,jO,kI)=X_Buf2(1:iVec-1,iO,jO,kI)+Vdm(jO,jI)*X_Buf1(1:iVec-1,iO,jI,kI)
      END DO; END DO
    END DO
  END DO

  ! last direction kI
  DO kI=0,NIn
    DO kO=0,NOut; DO jO=0,NOut; DO iO=0,NOut
      VECOUT(1:iVec-1,iO,jO,kO)=VECOUT(1:iVec-1,iO,jO,kO)+Vdm(kO,kI)*X_Buf2(1:iVec-1,iO,jO,kI)
    END DO; END DO; END DO
  END DO

  ! unpack solution from vector VECOUT
  iVec = 1
  DO WHILE (iVec < Dim1*PP_VEC)
    IF (mask_loc(Ind2).EQ.mask_ref_loc) THEN
      X_Out(:,:,:,:,Ind2) = VECOUT(iVec:iVec+Dim1-1,:,:,:)
      iVec = iVec + Dim1
    END IF
    Ind2 = Ind2 + 1
    IF (Ind2.GT.lastind) EXIT
  END DO
END DO  
END SUBROUTINE ChangeBasis3D_selective

PURE SUBROUTINE ChangeBasis2D_selective(Dim1,NIn,NOut,range_1,range_N,firstind,lastind,Vdm,X_In,X_Out,mask,mask_ref,&
        addToOutput)
!==================================================================================================================================
!==================================================================================================================================
! MODULES
USE MOD_PreProc
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------------------
! INPUT/OUTPUT VARIABLES
INTEGER,INTENT(IN)           :: Dim1,NIn,NOut,firstind,lastind,range_1,range_N
REAL,INTENT(IN)              :: X_In(1:Dim1,0:NIn,0:NIn     _ADD_DIM ,range_1:range_N)
REAL,INTENT(IN)              :: Vdm(0:NOut,0:NIn)
REAL,INTENT(INOUT)           :: X_Out(1:Dim1,0:NOut,0:NOut  _ADD_DIM ,range_1:range_N)
INTEGER,INTENT(IN),OPTIONAL  :: mask(range_1:range_N)
INTEGER,INTENT(IN),OPTIONAL  :: mask_ref
LOGICAL,INTENT(IN),OPTIONAL  :: addToOutput
!----------------------------------------------------------------------------------------------------------------------------------
! LOCAL VARIABLES
INTEGER             :: iI,jI,iO,jO,Ind,Ind2,iVec
REAL                :: X_Buf1(Dim1*PP_VEC,0:NOut,0:NIn)  ! first intermediate results from 1D interpolations
REAL                :: VECIN (Dim1*PP_VEC,0:NIn,0:NIn)
REAL                :: VECOUT(Dim1*PP_VEC,0:NOut,0:NOut)
INTEGER             :: mask_loc(firstind:lastind), mask_ref_loc
LOGICAL             :: addToOutput_loc
!==================================================================================================================================
IF (PRESENT(mask)) THEN
  mask_loc = mask(firstind:lastind)
  mask_ref_loc = mask_ref
ELSE
  mask_loc = 0
  mask_ref_loc = 0
END IF
addToOutput_loc=.FALSE.
IF (PRESENT(addToOutput)) THEN
  addToOutput_loc = addToOutput
END IF
Ind = firstind
Ind2 = firstind
DO WHILE (Ind.LE.lastind)
  ! pack solution into vector VECIN
  iVec = 1
  DO WHILE (iVec < Dim1*PP_VEC)
    IF (mask_loc(Ind).EQ.mask_ref_loc) THEN
      VECIN(iVec:iVec+Dim1-1,:,:)    = X_In(:,:,:   _ADD_DIM ,Ind)
      IF (addToOutput_loc) THEN
        ! initialize VECOUT with X_Out
        VECOUT(iVec:iVec+Dim1-1,:,:) = X_Out(:,:,:  _ADD_DIM ,Ind)
      END IF
      iVec = iVec + Dim1
    END IF
    Ind = Ind + 1
    IF (Ind.GT.lastind) EXIT
  END DO
  ! nullify VECOUT if not initialized with data from X_Out
  IF (.NOT.addToOutput_loc) THEN
    VECOUT=0.
  END IF

  ! first direction iI
  DO jI=0,NIn
    DO iO=0,NOut
      X_Buf1(1:iVec-1,iO,jI)=Vdm(iO,0)*VECIN(1:iVec-1,0,jI)
    END DO
    DO iI=1,NIn
      DO iO=0,NOut
        X_Buf1(1:iVec-1,iO,jI)=X_Buf1(1:iVec-1,iO,jI)+Vdm(iO,iI)*VECIN(1:iVec-1,iI,jI)
      END DO
    END DO
  END DO

  ! second direction jI
  DO jI=0,NIn
    DO jO=0,NOut; DO iO=0,NOut
      VECOUT(1:iVec-1,iO,jO)=VECOUT(1:iVec-1,iO,jO)+Vdm(jO,jI)*X_Buf1(1:iVec-1,iO,jI)
    END DO; END DO
  END DO

  ! unpack solution from vector VECOUT
  iVec = 1
  DO WHILE (iVec < Dim1*PP_VEC)
    IF (mask_loc(Ind2).EQ.mask_ref_loc) THEN
      X_Out(:,:,:  _ADD_DIM ,Ind2) = VECOUT(iVec:iVec+Dim1-1,:,:)
      iVec = iVec + Dim1
    END IF
    Ind2 = Ind2 + 1
    IF (Ind2.GT.lastind) EXIT
  END DO
END DO  
END SUBROUTINE ChangeBasis2D_selective

PURE SUBROUTINE ChangeBasis1D_selective(Dim1,NIn,NOut,range_1,range_N,firstind,lastind,Vdm,X_In,X_Out,mask,mask_ref,&
        addToOutput)
!==================================================================================================================================
!==================================================================================================================================
! MODULES
USE MOD_PreProc
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------------------
! INPUT/OUTPUT VARIABLES
INTEGER,INTENT(IN)           :: Dim1,NIn,NOut,firstind,lastind,range_1,range_N
REAL,INTENT(IN)              :: X_In(1:Dim1,0:NIn    _ADD_DIM ,range_1:range_N)
REAL,INTENT(IN)              :: Vdm(0:NOut,0:NIn)
REAL,INTENT(INOUT)           :: X_Out(1:Dim1,0:NOut  _ADD_DIM ,range_1:range_N)
INTEGER,INTENT(IN),OPTIONAL  :: mask(range_1:range_N)
INTEGER,INTENT(IN),OPTIONAL  :: mask_ref
LOGICAL,INTENT(IN),OPTIONAL  :: addToOutput
!----------------------------------------------------------------------------------------------------------------------------------
! LOCAL VARIABLES
INTEGER             :: iI,iO,Ind,Ind2,iVec
REAL                :: VECIN (Dim1*PP_VEC,0:NIn)
REAL                :: VECOUT(Dim1*PP_VEC,0:NOut)
INTEGER             :: mask_loc(firstind:lastind), mask_ref_loc
LOGICAL             :: addToOutput_loc
!==================================================================================================================================
IF (PRESENT(mask)) THEN
  mask_loc = mask(firstind:lastind)
  mask_ref_loc = mask_ref
ELSE
  mask_loc = 0
  mask_ref_loc = 0
END IF
addToOutput_loc=.FALSE.
IF (PRESENT(addToOutput)) THEN
  addToOutput_loc = addToOutput
END IF
Ind = firstind
Ind2 = firstind
DO WHILE (Ind.LE.lastind)
  ! pack solution into vector VECIN
  iVec = 1
  DO WHILE (iVec < Dim1*PP_VEC)
    IF (mask_loc(Ind).EQ.mask_ref_loc) THEN
      VECIN(iVec:iVec+Dim1-1,:) =    X_In(:,:   _ADD_DIM ,Ind)
      IF (addToOutput_loc) THEN
        ! initialize VECOUT with X_Out
        VECOUT(iVec:iVec+Dim1-1,:) = X_Out(:,:  _ADD_DIM ,Ind)
      END IF
      iVec = iVec + Dim1
    END IF
    Ind = Ind + 1
    IF (Ind.GT.lastind) EXIT
  END DO
  ! nullify VECOUT if not initialized with data from X_Out
  IF (.NOT.addToOutput_loc) THEN
    VECOUT=0.
  END IF

  ! first direction iI
  DO iI=0,NIn
    DO iO=0,NOut
      VECOUT(1:iVec-1,iO)=VECOUT(1:iVec-1,iO)+Vdm(iO,iI)*VECIN(1:iVec-1,iI)
    END DO
  END DO

  ! unpack solution from vector VECOUT
  iVec = 1
  DO WHILE (iVec < Dim1*PP_VEC)
    IF (mask_loc(Ind2).EQ.mask_ref_loc) THEN
      X_Out(:,:  _ADD_DIM ,Ind2) = VECOUT(iVec:iVec+Dim1-1,:)
      iVec = iVec + Dim1
    END IF
    Ind2 = Ind2 + 1
    IF (Ind2.GT.lastind) EXIT
  END DO
END DO  
END SUBROUTINE ChangeBasis1D_selective


PURE SUBROUTINE ChangeBasis3D_selective_inplace(Dim1,NIn,range_1,range_N,firstind,lastind,Vdm,X_InOut,mask,mask_ref)
!==================================================================================================================================
!==================================================================================================================================
! MODULES
USE MOD_PreProc
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------------------
! INPUT/OUTPUT VARIABLES
INTEGER,INTENT(IN)           :: Dim1,NIn,firstind,lastind,range_1,range_N
REAL,INTENT(INOUT)           :: X_InOut(1:Dim1,0:NIn,0:NIn,0:NIn,range_1:range_N)
REAL,INTENT(IN)              :: Vdm(0:NIn,0:NIn)
INTEGER,INTENT(IN),OPTIONAL  :: mask(range_1:range_N)
INTEGER,INTENT(IN),OPTIONAL  :: mask_ref
!----------------------------------------------------------------------------------------------------------------------------------
! LOCAL VARIABLES
INTEGER             :: iI,jI,kI,iO,jO,kO,Ind,Ind2,iVec
REAL                :: X_Buf1(Dim1*PP_VEC,0:NIn,0:NIn,0:NIn) ! first intermediate results from 1D interpolations
REAL                :: X_Buf2(Dim1*PP_VEC,0:NIn,0:NIn,0:NIn) ! first intermediate results from 1D interpolations
REAL                :: VECIN (Dim1*PP_VEC,0:NIn,0:NIn,0:NIn)
REAL                :: VECOUT(Dim1*PP_VEC,0:NIn,0:NIn,0:NIn)
INTEGER             :: mask_loc(firstind:lastind), mask_ref_loc
!==================================================================================================================================
IF (PRESENT(mask)) THEN
  mask_loc = mask(firstind:lastind)
  mask_ref_loc = mask_ref
ELSE
  mask_loc = 0
  mask_ref_loc = 0
END IF
Ind = firstind
Ind2 = firstind

DO WHILE (Ind.LE.lastind)
  ! pack solution into vector VECIN
  iVec = 1
  DO WHILE (iVec < Dim1*PP_VEC)
    IF (mask_loc(Ind).EQ.mask_ref_loc) THEN
      VECIN(iVec:iVec+Dim1-1,:,:,:) = X_InOut(:,:,:,:,Ind)
      iVec = iVec + Dim1
    END IF
    Ind = Ind + 1
    IF (Ind.GT.lastind) EXIT
  END DO
  VECOUT=0.


  ! first direction iI
  DO kI=0,NIn; DO jI=0,NIn
    DO iO=0,NIn
      X_Buf1(1:iVec-1,iO,jI,kI)=Vdm(iO,0)*VECIN(1:iVec-1,0,jI,kI)
    END DO
    DO iI=1,NIn
      DO iO=0,NIn
        X_Buf1(1:iVec-1,iO,jI,kI)=X_Buf1(1:iVec-1,iO,jI,kI)+Vdm(iO,iI)*VECIN(1:iVec-1,iI,jI,kI)
      END DO
    END DO
  END DO; END DO

  ! second direction jI
  DO kI=0,NIn
    DO jO=0,NIn; DO iO=0,NIn
      X_Buf2(1:iVec-1,iO,jO,kI)=Vdm(jO,0)*X_Buf1(1:iVec-1,iO,0,kI)
    END DO; END DO
    DO jI=1,NIn
      DO jO=0,NIn; DO iO=0,NIn
        X_Buf2(1:iVec-1,iO,jO,kI)=X_Buf2(1:iVec-1,iO,jO,kI)+Vdm(jO,jI)*X_Buf1(1:iVec-1,iO,jI,kI)
      END DO; END DO
    END DO
  END DO

  ! last direction kI
  DO kI=0,NIn
    DO kO=0,NIn; DO jO=0,NIn; DO iO=0,NIn
      VECOUT(1:iVec-1,iO,jO,kO)=VECOUT(1:iVec-1,iO,jO,kO)+Vdm(kO,kI)*X_Buf2(1:iVec-1,iO,jO,kI)
    END DO; END DO; END DO
  END DO

  ! unpack solution from vector VECOUT
  iVec = 1
  DO WHILE (iVec < Dim1*PP_VEC)
    IF (mask_loc(Ind2).EQ.mask_ref_loc) THEN
      X_InOut(:,:,:,:,Ind2) = VECOUT(iVec:iVec+Dim1-1,:,:,:)
      iVec = iVec + Dim1
    END IF
    Ind2 = Ind2 + 1
    IF (Ind2.GT.lastind) EXIT
  END DO
END DO  
END SUBROUTINE ChangeBasis3D_selective_inplace

PURE SUBROUTINE ChangeBasis2D_selective_inplace(Dim1,NIn,range_1,range_N,firstind,lastind,Vdm,X_InOut,mask,mask_ref)
!==================================================================================================================================
!==================================================================================================================================
! MODULES
USE MOD_PreProc
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------------------
! INPUT/OUTPUT VARIABLES
INTEGER,INTENT(IN)           :: Dim1,NIn,firstind,lastind,range_1,range_N
REAL,INTENT(INOUT)           :: X_InOut(1:Dim1,0:NIn,0:NIn   _ADD_DIM ,range_1:range_N)
REAL,INTENT(IN)              :: Vdm(0:NIn,0:NIn)
INTEGER,INTENT(IN),OPTIONAL  :: mask(range_1:range_N)
INTEGER,INTENT(IN),OPTIONAL  :: mask_ref
!----------------------------------------------------------------------------------------------------------------------------------
! LOCAL VARIABLES
INTEGER             :: iI,jI,iO,jO,Ind,Ind2,iVec
REAL                :: X_Buf1(Dim1*PP_VEC,0:NIn,0:NIn)  ! first intermediate results from 1D interpolations
REAL                :: VECIN (Dim1*PP_VEC,0:NIn,0:NIn)
REAL                :: VECOUT(Dim1*PP_VEC,0:NIn,0:NIn)
INTEGER             :: mask_loc(firstind:lastind), mask_ref_loc
!==================================================================================================================================
IF (PRESENT(mask)) THEN
  mask_loc = mask(firstind:lastind)
  mask_ref_loc = mask_ref
ELSE
  mask_loc = 0
  mask_ref_loc = 0
END IF
Ind = firstind
Ind2 = firstind

DO WHILE (Ind.LE.lastind)
  ! pack solution into vector VECIN
  iVec = 1
  DO WHILE (iVec < Dim1*PP_VEC)
    IF (mask_loc(Ind).EQ.mask_ref_loc) THEN
      VECIN(iVec:iVec+Dim1-1,:,:)    = X_InOut(:,:,:  _ADD_DIM ,Ind)
      iVec = iVec + Dim1
    END IF
    Ind = Ind + 1
    IF (Ind.GT.lastind) EXIT
  END DO

  ! first direction iI
  DO jI=0,NIn
    DO iO=0,NIn
      X_Buf1(1:iVec-1,iO,jI)=Vdm(iO,0)*VECIN(1:iVec-1,0,jI)
    END DO
    DO iI=1,NIn
      DO iO=0,NIn
        X_Buf1(1:iVec-1,iO,jI)=X_Buf1(1:iVec-1,iO,jI)+Vdm(iO,iI)*VECIN(1:iVec-1,iI,jI)
      END DO
    END DO
  END DO

  ! second direction jI
  VECOUT=0.
  DO jI=0,NIn
    DO jO=0,NIn; DO iO=0,NIn
      VECOUT(1:iVec-1,iO,jO)=VECOUT(1:iVec-1,iO,jO)+Vdm(jO,jI)*X_Buf1(1:iVec-1,iO,jI)
    END DO; END DO
  END DO

  ! unpack solution from vector VECOUT
  iVec = 1
  DO WHILE (iVec < Dim1*PP_VEC)
    IF (mask_loc(Ind2).EQ.mask_ref_loc) THEN
      X_InOut(:,:,:  _ADD_DIM ,Ind2) = VECOUT(iVec:iVec+Dim1-1,:,:)
      iVec = iVec + Dim1
    END IF
    Ind2 = Ind2 + 1
    IF (Ind2.GT.lastind) EXIT
  END DO
END DO  
END SUBROUTINE ChangeBasis2D_selective_inplace

PURE SUBROUTINE ChangeBasis1D_selective_inplace(Dim1,NIn,range_1,range_N,firstind,lastind,Vdm,X_InOut,mask,mask_ref)
!==================================================================================================================================
!==================================================================================================================================
! MODULES
USE MOD_PreProc
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------------------
! INPUT/OUTPUT VARIABLES
INTEGER,INTENT(IN)           :: Dim1,NIn,firstind,lastind,range_1,range_N
REAL,INTENT(INOUT)           :: X_InOut(1:Dim1,0:NIn   _ADD_DIM ,range_1:range_N)
REAL,INTENT(IN)              :: Vdm(0:NIn,0:NIn)
INTEGER,INTENT(IN),OPTIONAL  :: mask(range_1:range_N)
INTEGER,INTENT(IN),OPTIONAL  :: mask_ref
!----------------------------------------------------------------------------------------------------------------------------------
! LOCAL VARIABLES
INTEGER             :: iI,iO,Ind,Ind2,iVec
REAL                :: VECIN (Dim1*PP_VEC,0:NIn)
REAL                :: VECOUT(Dim1*PP_VEC,0:NIn)
INTEGER             :: mask_loc(firstind:lastind), mask_ref_loc
!==================================================================================================================================
IF (PRESENT(mask)) THEN
  mask_loc = mask(firstind:lastind)
  mask_ref_loc = mask_ref
ELSE
  mask_loc = 0
  mask_ref_loc = 0
END IF
Ind = firstind
Ind2 = firstind
DO WHILE (Ind.LE.lastind)
  ! pack solution into vector VECIN
  iVec = 1
  DO WHILE (iVec < Dim1*PP_VEC)
    IF (mask_loc(Ind).EQ.mask_ref_loc) THEN
      VECIN(iVec:iVec+Dim1-1,:) =    X_InOut(:,:  _ADD_DIM ,Ind)
      iVec = iVec + Dim1
    END IF
    Ind = Ind + 1
    IF (Ind.GT.lastind) EXIT
  END DO

  ! first direction iI
  VECOUT=0.
  DO iI=0,NIn
    DO iO=0,NIn
      VECOUT(1:iVec-1,iO)=VECOUT(1:iVec-1,iO)+Vdm(iO,iI)*VECIN(1:iVec-1,iI)
    END DO
  END DO

  ! unpack solution from vector VECOUT
  iVec = 1
  DO WHILE (iVec < Dim1*PP_VEC)
    IF (mask_loc(Ind2).EQ.mask_ref_loc) THEN
      X_InOut(:,:  _ADD_DIM ,Ind2) = VECOUT(iVec:iVec+Dim1-1,:)
      iVec = iVec + Dim1
    END IF
    Ind2 = Ind2 + 1
    IF (Ind2.GT.lastind) EXIT
  END DO
END DO  
END SUBROUTINE ChangeBasis1D_selective_inplace

!==================================================================================================================================
!> Interpolate a 3D tensor product Lagrange polynomial defined by (NIn+1) 1D Lagrange basis functions of order (Nin) and node 
!> positions xi_In(0:Nin) to another 3D tensor product Lagrange basis defined by (NOut+1) 1D interpolation points on the node
!> positions xi_out(0:NOut).
!> xi is defined in the 1D referent element \f$ \xi \in [-1,1] \f$.
!>  _Single is only suitable for one tensor product element
!==================================================================================================================================
PURE SUBROUTINE ChangeBasis3D_Single(Dim1,NIn,NOut,Vdm,X_In,X_Out)
! MODULES
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------------------
! INPUT/OUTPUT VARIABLES
INTEGER,INTENT(IN)  :: Dim1                                    !< Number of variables
INTEGER,INTENT(IN)  :: NIn                                     !< Input polynomial degree, no. of points = NIn+1
INTEGER,INTENT(IN)  :: NOut                                    !< Output polynomial degree, no. of points = NOut+1
REAL,INTENT(IN)     :: X_In(1:Dim1,0:NIn,0:NIn,0:NIn)          !< Input field, dimensions must match Dim1,NIn
REAL,INTENT(OUT)    :: X_Out(1:Dim1,0:NOut,0:NOut,0:NOut)      !< Output field, dimensions must match Dim1,NOut
REAL,INTENT(IN)     :: Vdm(0:NOut,0:NIn)                       !< 1D Vandermonde In -> Out
!----------------------------------------------------------------------------------------------------------------------------------
! LOCAL VARIABLES
INTEGER             :: iI,jI,kI,iO,jO,kO
REAL                :: X_Buf1(1:Dim1,0:NOut,0:NIn,0:NIn)       ! first intermediate results from 1D interpolations
REAL                :: X_Buf2(1:Dim1,0:NOut,0:NOut,0:NIn)      ! second intermediate results from 1D interpolations
!==================================================================================================================================
X_buf1=0.
! first direction iI
DO kI=0,NIn; DO jI=0,NIn; DO iI=0,NIn
  DO iO=0,NOut
    X_Buf1(:,iO,jI,kI)=X_Buf1(:,iO,jI,kI)+Vdm(iO,iI)*X_In(:,iI,jI,kI)
  END DO
END DO; END DO; END DO
X_buf2=0.
! second direction jI
DO kI=0,NIn; DO jI=0,NIn; DO jO=0,NOut
  DO iO=0,NOut
    X_Buf2(:,iO,jO,kI)=X_Buf2(:,iO,jO,kI)+Vdm(jO,jI)*X_Buf1(:,iO,jI,kI)
  END DO
END DO; END DO; END DO
X_Out=0.
! last direction kI
DO kI=0,NIn; DO kO=0,NOut; DO jO=0,NOut
  DO iO=0,NOut
    X_Out(:,iO,jO,kO)=X_Out(:,iO,jO,kO)+Vdm(kO,kI)*X_Buf2(:,iO,jO,kI)
  END DO
END DO; END DO; END DO
END SUBROUTINE ChangeBasis3D_Single

PURE SUBROUTINE ChangeBasis2D_Single(Dim1,NIn,NOut,Vdm,X_In,X_Out)
! MODULES
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------------------
! INPUT/OUTPUT VARIABLES
INTEGER,INTENT(IN)  :: Dim1                                    !< Number of variables
INTEGER,INTENT(IN)  :: NIn                                     !< Input polynomial degree, no. of points = NIn+1
INTEGER,INTENT(IN)  :: NOut                                    !< Output polynomial degree, no. of points = NOut+1
REAL,INTENT(IN)     :: X_In(1:Dim1,0:NIn,0:NIn    _ADD_DIM)   !< Input field, dimensions must match Dim1,NIn
REAL,INTENT(OUT)    :: X_Out(1:Dim1,0:NOut,0:NOut _ADD_DIM)   !< Output field, dimensions must match Dim1,NOut
REAL,INTENT(IN)     :: Vdm(0:NOut,0:NIn)                       !< 1D Vandermonde In -> Out
!----------------------------------------------------------------------------------------------------------------------------------
! LOCAL VARIABLES
INTEGER             :: iI,jI,iO,jO
REAL                :: X_Buf1(1:Dim1,0:NOut,0:NIn)       ! first intermediate results from 1D interpolations
!==================================================================================================================================
X_buf1=0.
! first direction iI
DO jI=0,NIn; DO iI=0,NIn
  DO iO=0,NOut
    X_Buf1(:,iO,jI)=X_Buf1(:,iO,jI)+Vdm(iO,iI)*X_In(:,iI,jI _ADD_DIM)
  END DO
END DO; END DO
X_Out=0.
! second direction jI
DO jI=0,NIn; DO jO=0,NOut
  DO iO=0,NOut
    X_Out(:,iO,jO _ADD_DIM)=X_Out(:,iO,jO _ADD_DIM)+Vdm(jO,jI)*X_Buf1(:,iO,jI)
  END DO
END DO; END DO
END SUBROUTINE ChangeBasis2D_Single
SUBROUTINE ChangeBasis1D_Single(Dim1,NIn,NOut,Vdm,X_In,X_Out)
! MODULES
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------------------
! INPUT/OUTPUT VARIABLES
INTEGER,INTENT(IN)  :: Dim1                                    !< Number of variables
INTEGER,INTENT(IN)  :: NIn                                     !< Input polynomial degree, no. of points = NIn+1
INTEGER,INTENT(IN)  :: NOut                                    !< Output polynomial degree, no. of points = NOut+1
REAL,INTENT(IN)     :: X_In(1:Dim1,0:NIn   _ADD_DIM)          !< Input field, dimensions must match Dim1,NIn
REAL,INTENT(OUT)    :: X_Out(1:Dim1,0:NOut _ADD_DIM)          !< Output field, dimensions must match Dim1,NOut
REAL,INTENT(IN)     :: Vdm(0:NOut,0:NIn)                       !< 1D Vandermonde In -> Out
!----------------------------------------------------------------------------------------------------------------------------------
! LOCAL VARIABLES
INTEGER             :: iI,iO
!==================================================================================================================================
X_Out=0.
! first direction iI
DO iI=0,NIn
  DO iO=0,NOut
    X_Out(:,iO _ADD_DIM)=X_Out(:,iO _ADD_DIM)+Vdm(iO,iI)*X_In(:,iI _ADD_DIM)
  END DO
END DO
END SUBROUTINE ChangeBasis1D_Single

!==================================================================================================================================
!> Interpolate a 3D tensor product Lagrange polynomial defined by (NIn+1) 1D Lagrange basis functions of order (Nin) and node 
!> positions xi_In(0:Nin) to another 3D tensor product Lagrange basis defined by (NOut+1) 1D interpolation points on the node
!> positions xi_out(0:NOut) using DIFFERENT 1D Vdm matrices in the xi,eta and zeta directions.
!> xi is defined in the 1D referent element \f$ \xi \in [-1,1] \f$.
!==================================================================================================================================
PURE SUBROUTINE ChangeBasis3D_XYZ(Dim1,NIn,NOut,Vdm_xi,Vdm_eta,Vdm_zeta,X3D_In,X3D_Out)
! MODULES
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------------------
! INPUT/OUTPUT VARIABLES
INTEGER,INTENT(IN)  :: Dim1                                    !< Number of variables
INTEGER,INTENT(IN)  :: NIn                                     !< Input polynomial degree, no. of points = NIn+1
INTEGER,INTENT(IN)  :: NOut                                    !< Output polynomial degree, no. of points = NOut+1
REAL,INTENT(IN)     :: X3D_In(1:Dim1,0:NIn,0:NIn,0:NIn)        !< Input field, dimensions must match Dim1,NIn
REAL,INTENT(OUT)    :: X3D_Out(1:Dim1,0:NOut,0:NOut,0:NOut)    !< Output field, dimensions must match Dim1,NOut
REAL,INTENT(IN)     :: Vdm_xi(0:NOut,0:NIn)                    !< 1D Vandermonde In -> Out xi direction
REAL,INTENT(IN)     :: Vdm_eta(0:NOut,0:NIn)                   !< 1D Vandermonde In -> Out eta direction
REAL,INTENT(IN)     :: Vdm_zeta(0:NOut,0:NIn)                  !< 1D Vandermonde In -> Out zeta direction

!----------------------------------------------------------------------------------------------------------------------------------
! LOCAL VARIABLES
INTEGER             :: iI,jI,kI,iO,jO,kO
REAL                :: X3D_Buf1(1:Dim1,0:NOut,0:NIn,0:NIn)     ! first intermediate results from 1D interpolations
REAL                :: X3D_Buf2(1:Dim1,0:NOut,0:NOut,0:NIn)    ! second intermediate results from 1D interpolations
!==================================================================================================================================
X3D_buf1=0.
! first direction iI
DO kI=0,NIn
  DO jI=0,NIn
    DO iI=0,NIn
      DO iO=0,NOut
        X3D_Buf1(:,iO,jI,kI)=X3D_Buf1(:,iO,jI,kI)+Vdm_xi(iO,iI)*X3D_In(:,iI,jI,kI)
      END DO
    END DO
  END DO
END DO
X3D_buf2=0.
! second direction jI
DO kI=0,NIn
  DO jI=0,NIn
    DO jO=0,NOut
      DO iO=0,NOut
        X3D_Buf2(:,iO,jO,kI)=X3D_Buf2(:,iO,jO,kI)+Vdm_eta(jO,jI)*X3D_Buf1(:,iO,jI,kI)
      END DO
    END DO
  END DO
END DO
X3D_Out=0.
! last direction kI
DO kI=0,NIn
  DO kO=0,NOut
    DO jO=0,NOut
      DO iO=0,NOut
        X3D_Out(:,iO,jO,kO)=X3D_Out(:,iO,jO,kO)+Vdm_zeta(kO,kI)*X3D_Buf2(:,iO,jO,kI)
      END DO
    END DO
  END DO
END DO
END SUBROUTINE ChangeBasis3D_XYZ

